MySQL

# 基础架构

MySQL可以分为Server层和存储引擎层两部分

架构图

![](../images/架构图.png)

Server层包括连接器、查询缓存、分析器、优化器、执行器构成。涵盖MySQL大部分核心服务功能，以及内置函数，同时跨存储引擎的功能都在本层实现（存储过程、触发器、视图）

存储引擎层负责数据的存储和提取。插件式架构，支持InnoDB、MyISAM等多个存储引擎。现在主要是InnoDB（**默认**，可以通过create table语句中使用engine=memory 指定相应的引擎）。

1.**连接器**

负责与客户端建立连接、获取权限、维持和管理连接。

```mysql
mysql -h%ip -P$port -u$user -p
```

然后输入密码，在完成TCP握手之后，连接器开始认证身份。

查看空闲状态：show processlist根据Command "sleep空闲"

wait_timeout：超时控制，默认值8小时

数据库长连接：连接成功后，客户端持续有请求，一直使用一个连接。

短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立。

**建立过程比较复杂，建议尽可能使用长连接**

故障场景：MySQL异常重启

产生原因：使用长连接导致MySQL占用内存很多，只有在连接断开才会释放，长期累积导致OOM，MySQL异常重启。

解决方案：

1. 定期断开长连接。通过判断占用内存大查询之后，断开连接，之后查询再重连。

2.  MySQL 5.7之后版本，可以通过执行mysql_reset_connection来重新初始化连接资源。不需要做重连和重新做设备权限验证，但是可以回复刚刚创建完的状态。

2.**查询缓存**

get到查询请求之后，mysql会先查询缓存。潘顿是否执行过此条语句，之前执行的语句、结果都以key-value对的形式进行存储，key对应查询语句，value对应结果。若存在此条语句执行记录，直接返回value给客户端。

**查询缓存弊大于利**

查询缓存失效很频繁，若存在查询语句中一个表由更新，那么这个表上的所有查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率就会很低。

MySQL提供“按需使用”的方式，通过设置query_cache_type为DEMAND，使得默认SQL都不适用查询缓存。对于确定使用查询缓存的语句，可以使用SQL_CACHE显示指定。（**仅限MySQL 8.0之前的版本**）

```mysql
 select SQL_CACHE * from T where ID=10；
```

3.**分析器**

词法分析，语法分析

4.**优化器**

优化器实在表里面存在多个索引时，决定使用那个索引；当语句存在多表关联（join）的时候，决定表的连接顺序。

执行计划生成，索引选择

5.**执行器**

首先判断用户权限对这个表是否有执行查询的权限。若有权限则继续运行，打开表的时候，执行器就会根据表的引擎定义，使用这个引擎提供的接口。

```mysql
select *  from T where ID=10;
```

执行流程：

1. 调用InnoDB引擎接口取本表第一行，判断ID值是不是10，不是则跳过，是则存入结果集中。
2. 调用引擎接口取”下一行“，若存在相同的判断逻辑，直到取到表的最后一行。
3. 执行器将上述遍历过程所有满足条件的行组成结果集返回给客户端。

对于加索引的表，第一次调用的是”取满足条件的第一行“这个接口，之后循环取”满足条件的下一行“这个接口，这下接口都是引擎中定义好的。

row_examined：这个语句在执行过程中扫描了多少行，这个值是执行器每次调用引擎获取数据行累加的。扫描引擎行数与row_examined并不是完全相同。

操作引擎，返回相应结果



